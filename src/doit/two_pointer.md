# [알고리즘] 투 포인터 (Two Pointers)

**투 포인터**는 두 개의 포인터를 사용하여 배열(또는 리스트)을 탐색하며, 특정 조건을 만족하는 값을 효율적으로 찾는 기법입니다.  
이 기법은 보통 정렬된 배열이나 리스트에서 자주 사용되며, 선형 시간 복잡도(**O(N)**)로 문제를 해결할 수 있습니다.

---

## 기본 아이디어

1. **두 개의 포인터**를 배열의 시작 또는 끝에 배치하고 문제 조건에 따라 이동합니다.
2. 배열 구간을 조작하여 조건을 만족하는 값을 찾아냅니다.
3. 반복문을 통해, 간단한 덧셈/뺄셈 등으로 계산을 진행하면서 효율적으로 답을 찾아냅니다.
4. 시간 복잡도는 **O(N)** 입니다.

---

## 코드 예제

아래는 배열에서 합이 `7`인 부분 배열을 찾는 코드를 보여줍니다:

```java
int[] nums = {1, 2, 3, 4, 5};
int start = 0, end = 0, sum = 0, target = 7;

while (end < nums.length) {
    sum += nums[end];
    
    while (sum > target) {
        sum -= nums[start++];
    }
    
    if (sum == target) {
        System.out.println("부분 배열: [" + start + ", " + end + "]");
        break;
    }
    end++;
}
```

---

### 실행 흐름 (예제: 합이 7을 찾을 때)

- `nums = {1, 2, 3, 4, 5}`이고, `target = 7`
- `start = 0`, `end = 0`, `sum = 0`

1. `nums[end]`(1) 추가 → `sum = 1`
2. `nums[end]`(2) 추가 → `sum = 3`
3. `nums[end]`(3) 추가 → `sum = 6`
4. `nums[end]`(4) 추가 → `sum = 10` **→ 합이 초과, start 이동**
5. `nums[start]`(1) 제거 → `sum = 9`
6. `nums[start]`(2) 제거 → `sum = 7` **→ 조건 만족**

**정답:** `[2, 3]`

---

## 활용 예제

1. **정렬된 배열에서 특정한 두 숫자의 합 찾기**
    - 문제로 자주 등장하는 "Two Sum" 문제 해결
2. **특정 조건을 만족하는 부분 배열 찾기**
    - 배열의 합, 곱 또는 특정 조건의 최적값 계산
3. **슬라이딩 윈도우와 결합하여 활용 가능**
    - 고정된 길이 또는 가변 길이의 조건을 만족하는 문제에 효과적

---

## 시간 복잡도

- **최악의 경우**에도 배열을 한 번만 순회하므로 시간 복잡도는 **O(N)** 입니다.
- 두 포인터가 독립적으로 이동함에 따라, 전체 배열을 두 번 순회하지 않도록 구현한 점이 효율성을 보장합니다.
