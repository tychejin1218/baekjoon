# [알고리즘] 삽입 정렬 (Insertion Sort)

**삽입 정렬**은 정렬되지 않은 데이터를 정렬된 부분에 **삽입**하여 정렬을 진행하는 방식입니다.  
정렬이 진행됨에 따라 왼쪽 부분(이미 확인된 데이터)부터 순차적으로 정렬됩니다.

---

## 시간 복잡도
- 최선: `O(N)` (이미 배열이 정렬된 경우)
- 평균: `O(N²)`
- 최악: `O(N²)`

---

## 특징
- **작은 배열**이나 **이미 정렬된 배열**에서는 매우 효율적.
- **안정 정렬 (Stable Sort)**: 동일한 값의 상대적인 순서가 유지됩니다.
- 추가 메모리 할당이 필요 없는 **제자리 정렬(In-place Sort)**입니다.

---

## 실행 흐름 (단계별 설명)

예: **정렬 대상 배열**: `[5, 3, 8, 4, 2]`

#### 첫 번째 단계 (i = 1)
1. **현재 값(`3`)을 key로 설정**하고, 왼쪽 부분(`[5]`)과 비교.
2. 비교: `(5 > 3)`이므로 `5`를 오른쪽으로 이동: `[5, 5, 8, 4, 2]`
3. **key(3)를 올바른 위치에 삽입**: `[3, 5, 8, 4, 2]`

#### 두 번째 단계 (i = 2)
1. **현재 값(`8`)을 key로 설정**하고, 왼쪽 부분(`{3, 5}`)과 비교.
2. 비교: `(5 < 8)` → key(8)는 이미 정렬된 위치에 있음: `[3, 5, 8, 4, 2]`

#### 세 번째 단계 (i = 3)
1. **현재 값(`4`)을 key로 설정**하고, 왼쪽 부분(`{3, 5, 8}`)과 비교.
2. 비교: `(8 > 4)`이므로 `8`을 오른쪽으로 이동 → `[3, 5, 8, 8, 2]`
3. 비교: `(5 > 4)`이므로 `5`를 오른쪽으로 이동 → `[3, 5, 5, 8, 2]`
4. 비교: `(3 < 4)` → 정지 후, **key(4)를 삽입**: `[3, 4, 5, 8, 2]`

#### 네 번째 단계 (i = 4)
1. **현재 값(`2`)을 key로 설정**하고, 왼쪽 부분(`{3, 4, 5, 8}`)과 비교.
2. 비교: `(8 > 2)` → `8` 오른쪽 이동 → `[3, 4, 5, 8, 8]`
3. 비교: `(5 > 2)` → `5` 오른쪽 이동 → `[3, 4, 5, 5, 8]`
4. 비교: `(4 > 2)` → `4` 오른쪽 이동 → `[3, 4, 4, 5, 8]`
5. 비교: `(3 > 2)` → `3` 오른쪽 이동 → `[3, 3, 4, 5, 8]`
6. **key(2)를 배열 가장 앞에 삽입**: `[2, 3, 4, 5, 8]`

---

## 코드 예제

```java
public class InsertionSort {
  
    public static void insertionSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i]; // 삽입될 요소
            int j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j]; // 값을 한 칸 오른쪽으로 이동
                j--;
            }
            arr[j + 1] = key; // key를 정확한 위치에 삽입
        }
    }

    public static void main(String[] args) {
        int[] arr = {5, 3, 8, 4, 2};
        insertionSort(arr);
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```

---

## 실행 예제
**정렬 대상 배열**: `[5, 3, 8, 4, 2]`

### 동작 과정:
- 첫 번째 단계 (i=1): `[3, 5, 8, 4, 2]`
- 두 번째 단계 (i=2): `[3, 5, 8, 4, 2]` (변화 없음)
- 세 번째 단계 (i=3): `[3, 4, 5, 8, 2]`
- 네 번째 단계 (i=4): `[2, 3, 4, 5, 8]`

**최종 결과 출력:** `2 3 4 5 8`

---

## 활용 예제

### 1. 라이브러리에서 자동 정렬 구현
- 삽입 정렬은 대부분의 고성능 라이브러리에서 작은 배열(일반적으로 16개 이하)에 대해 사용됩니다.  
  예: Java의 `TimSort` 구현에서 작은 데이터는 삽입 정렬로 처리됨.

---

## 참고
삽입 정렬은 데이터가 이미 대부분 정렬된 경우 이상적으로 작동하고, **작은 데이터셋**의 경우 빠르고 효율적입니다. 그러나 데이터 크기가 커지면 시간 복잡도가 `O(N²)`로 증가하므로 퀵 정렬이나 병합 정렬과 같은 더 효율적인 방법이 권장됩니다.
