# [알고리즘] 병합 정렬 (Merge Sort)

**병합 정렬**은 배열을 재귀적으로 반으로 나누고, 이후에 부분 배열을 병합하며 정렬하는 알고리즘입니다.  
분할 정복(Divide and Conquer)을 활용해 구현됩니다.

---

## 시간 복잡도
- **최선**: `O(N log N)`
- **평균**: `O(N log N)`
- **최악**: `O(N log N)`

---

## 특징
- **안정 정렬 (Stable Sort)**: 동일한 값의 상대 순서가 유지됩니다.
- 정렬을 수행하기 위해 **추가 메모리(O(N))가 필요**합니다.
- 데이터 크기가 클수록 효율적이지만, 추가 메모리 사용 부담이 있습니다.

---

## 실행 흐름 (단계별 설명)

### 정렬 대상 배열: `[5, 3, 8, 4, 2]`

#### 1. 재귀적으로 분할
1. **Step 1**: 배열을 반으로 나눕니다.
    - 입력 배열: `[5, 3, 8, 4, 2]`
    - 분할: `[5, 3, 8]` | `[4, 2]`

2. **Step 2**: 각 부분 배열을 계속 반으로 나눕니다.
    - `[5, 3, 8]` → `[5] | [3, 8]`
    - `[4, 2]` → `[4] | [2]`
    - `[3, 8]` → `[3] | [8]`

   **결과**: 모든 배열이 하나의 요소로 분할됩니다.

---

#### 2. 병합과 정렬
이제 각 배열을 병합하며 정렬합니다.

1. **Step 3**: 두 값을 병합하여 정렬합니다.
    - `[3] | [8]` → `[3, 8]`
    - `[4] | [2]` → `[2, 4]`

2. **Step 4**: 다시 병합합니다.
    - `[5] | [3, 8]` → `[3, 5, 8]`
    - `[2, 4] | []` → `[2, 4]`

3. **Step 5**: 최종 병합.
    - `[3, 5, 8] | [2, 4]` → `[2, 3, 4, 5, 8]`

**최종 결과:** `[2, 3, 4, 5, 8]`

---

## 코드 예제

```java
public class MergeSort {
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;

            // Divide: 왼쪽과 오른쪽으로 나눔
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);

            // Conquer: 분할된 배열 병합 및 정렬
            merge(arr, left, mid, right);
        }
    }

    private static void merge(int[] arr, int left, int mid, int right) {
        // 병합을 위한 임시 배열
        int[] temp = new int[right - left + 1];
        int i = left, j = mid + 1, k = 0;

        // 두 배열 병합
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }

        // 왼쪽 배열에 남은 값을 추가
        while (i <= mid) {
            temp[k++] = arr[i++];
        }

        // 오른쪽 배열에 남은 값을 추가
        while (j <= right) {
            temp[k++] = arr[j++];
        }

        // 정렬된 내용을 원본 배열에 복사
        for (int idx = 0; idx < temp.length; idx++) {
            arr[left + idx] = temp[idx];
        }
    }

    public static void main(String[] args) {
        int[] arr = {5, 3, 8, 4, 2};
        mergeSort(arr, 0, arr.length - 1);

        // 결과 출력
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```

---

## 실행 예제

**정렬 대상 배열:** `[5, 3, 8, 4, 2]`

### 분할 및 병합 과정
1. **초기 분할**:  
   `[5, 3, 8]` | `[4, 2]`

2. **부분 정렬 및 병합**:  
   `[5] | [3, 8] → [3, 5, 8]`  
   `[4] | [2] → [2, 4]`

3. **최종 병합**:  
   `[3, 5, 8]` | `[2, 4]` → `[2, 3, 4, 5, 8]`

**최종 결과 출력**: `2 3 4 5 8`

---

## 활용 예제

### 1. 대규모 데이터 정렬
- 병합 정렬은 매우 큰 데이터 세트를 효율적으로 정렬할 수 있습니다.
- 정렬 대상이 외부 메모리에 저장된 경우에도 안정적으로 동작(외부 정렬).

---

### 2. 안정성 요구 정렬
- 원소의 **중복이 많은 데이터**를 정렬하되, 기존 순서를 유지해야 할 때 적합합니다.
- 예: 이름순으로 정렬된 데이터에서 동일 이름의 나이순으로 정렬.

---

### 3. 정렬 라이브러리 내부 활용
- 병합 정렬은 Java 및 여러 언어의 정렬 라이브러리에서 핵심적으로 사용됩니다.
- 예: Python의 `sorted()`에서 사용되는 TimSort는 내부적으로 병합 정렬 기반.

---

## 참고
병합 정렬은 항상 `O(N log N)`의 시간 복잡도를 가지므로 안정적입니다.  
하지만 **추가 메모리 공간 O(N)** 이 필요한 단점이 있으므로, 메모리가 제한적인 환경에서는 퀵 정렬과 같은 다른 알고리즘을 고려할 수 있습니다.
