# [알고리즘] 선택 정렬 (Selection Sort)

**선택 정렬**은 리스트 내에서 가장 작은 값을 찾고, 해당 값을 앞쪽에 배치하는 과정을 반복합니다.  
정렬이 진행됨에 따라 배열의 앞부분부터 점차 정렬된 상태가 됩니다.

---

## 시간 복잡도
- 최선: `O(N²)`
- 평균: `O(N²)`
- 최악: `O(N²)`

---

## 특징
- **단순한 구조로 이해하기 쉬움** : 기본적인 반복문과 비교 작업으로 정렬 수행
- **비교 횟수가 많음** : N개의 원소가 있다면 총 N²에 가까운 비교가 필요
- **데이터 교환 횟수는 적음** : 각 패스(Pass)마다 최대 한 번의 교환만 수행
- **비안정 정렬(Unstable Sort)** : 동일한 값이 순서가 바뀔 수도 있음

---

## 실행 흐름 (단계별 설명)

예: **정렬 대상 배열**: `[5, 3, 8, 4, 2]`

#### 첫 번째 패스 (Pass 1)
1. 배열의 첫 번째부터 끝까지 탐색하여 **최솟값**을 찾음. (현재 배열: `[5, 3, 8, 4, 2]`)
    - 비교: `(5, 3)` → 최솟값은 3 (인덱스 1)
    - 비교: `(3, 8)`
    - 비교: `(3, 4)`
    - 비교: `(3, 2)` → 최솟값은 2 (인덱스 4)
2. **최솟값(2)을 첫 번째 값(인덱스 0)과 교환**: `[2, 3, 8, 4, 5]`

#### 두 번째 패스 (Pass 2)
1. 두 번째부터 끝까지 탐색하여 **최솟값**을 찾음. (현재 배열: `[2, 3, 8, 4, 5]`)
    - 비교: `(3, 8)`
    - 비교: `(3, 4)`
    - 비교: `(3, 5)`
2. 최솟값은 **3** (이미 두 번째 위치에 있음), 교환 없음: `[2, 3, 8, 4, 5]`

#### 세 번째 패스 (Pass 3)
1. 세 번째부터 끝까지 탐색하여 **최솟값**을 찾음. (현재 배열: `[2, 3, 8, 4, 5]`)
    - 비교: `(8, 4)` → 최솟값은 4 (인덱스 3)
    - 비교: `(4, 5)`
2. **최솟값(4)을 세 번째 값(인덱스 2)과 교환**: `[2, 3, 4, 8, 5]`

#### 네 번째 패스 (Pass 4)
1. 네 번째부터 끝까지 탐색하여 **최솟값**을 찾음. (현재 배열: `[2, 3, 4, 8, 5]`)
    - 비교: `(8, 5)` → 최솟값은 5 (인덱스 4)
2. **최솟값(5)을 네 번째 값(인덱스 3)과 교환**: `[2, 3, 4, 5, 8]`

---

## 코드 예제

```java
public class SelectionSort {
  
  public static void selectionSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
      int minIndex = i; // 현재 위치를 최소값 인덱스로 설정
      for (int j = i + 1; j < arr.length; j++) {
        if (arr[j] < arr[minIndex]) {
          minIndex = j; // 더 작은 값이 발견되면 최소값 인덱스 업데이트
        }
      }
      // Swap
      int temp = arr[minIndex];
      arr[minIndex] = arr[i];
      arr[i] = temp; // 현재 위치와 최소값 위치 교환
    }
  }

  public static void main(String[] args) {
    int[] arr = {5, 3, 8, 4, 2};
    selectionSort(arr);
    for (int num : arr) {
      System.out.print(num + " ");
    }
  }
}
```

---

## 실행 예제
**정렬 대상 배열**: `[5, 3, 8, 4, 2]`

### 동작 과정:
- 첫 번째 패스 → `[2, 3, 8, 4, 5]`
- 두 번째 패스 → `[2, 3, 8, 4, 5]` (변화 없음)
- 세 번째 패스 → `[2, 3, 4, 8, 5]`
- 네 번째 패스 → `[2, 3, 4, 5, 8]`

**최종 결과 출력:** `2 3 4 5 8`

---

## 활용 예제

### 1. 자체 정렬이 불가능한 환경
- 특정 언어나 환경에서 `sort()` API 없이 정렬 알고리즘 구현할 때 선택 정렬은 간단하고 실용적으로 사용 가능.

---

## 참고
선택 정렬은 구조가 간단하여 학습 목적으로 활용되지만, 실제 대규모 데이터 처리를 위한 최적화된 알고리즘(예: 퀵 정렬, 병합 정렬)에는 비효율적임. 특히, 데이터가 많아질수록 성능이 급격히 저하됨.
